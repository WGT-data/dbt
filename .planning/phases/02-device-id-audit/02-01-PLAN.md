---
phase: 02-device-id-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - analyses/audit_device_id_formats.sql
  - analyses/baseline_match_rates.sql
  - analyses/amplitude_device_id_investigation.sql
  - analyses/README.md
autonomous: true

must_haves:
  truths:
    - "SQL queries exist that profile device ID columns across both Adjust and Amplitude source tables by platform"
    - "SQL queries exist that calculate baseline match rates between Adjust device IDs and Amplitude device IDs by platform"
    - "SQL query exists that investigates Amplitude DEVICE_ID format for Android (random vs GPS_ADID) with real column inspection"
    - "All queries are self-contained Snowflake SQL ready to paste into dbt Cloud IDE or Snowflake worksheet"
  artifacts:
    - path: "analyses/audit_device_id_formats.sql"
      provides: "Device ID column profiling across Adjust iOS/Android source tables"
      contains: "GROUP BY PLATFORM"
    - path: "analyses/baseline_match_rates.sql"
      provides: "Match rate calculation between Adjust and Amplitude by platform and ID type"
      contains: "android_gps_adid"
    - path: "analyses/amplitude_device_id_investigation.sql"
      provides: "Amplitude DEVICE_ID format investigation for Android and iOS"
      contains: "EVENTS_726530"
    - path: "analyses/README.md"
      provides: "Instructions for running audit queries and capturing results"
      contains: "dbt Cloud"
  key_links:
    - from: "analyses/audit_device_id_formats.sql"
      to: "ADJUST.S3_DATA.IOS_ACTIVITY_INSTALL"
      via: "Direct source table reference"
      pattern: "IOS_ACTIVITY_INSTALL"
    - from: "analyses/baseline_match_rates.sql"
      to: "AMPLITUDEANALYTICS_AMPLITUDE_DB_364926_SHARE.SCHEMA_726530.EVENTS_726530"
      via: "Direct source table reference for Amplitude join"
      pattern: "EVENTS_726530"
---

<objective>
Write SQL analysis queries to audit device ID formats and measure baseline match rates across Adjust and Amplitude source tables.

Purpose: These audit queries are the investigation tools for Phase 2. They must be run in dbt Cloud IDE or Snowflake worksheet to produce real results that will populate the documentation artifacts in Plan 02. Without these queries, we cannot establish the baseline metrics that Phase 3 normalization will be measured against.

Output: 3 SQL analysis files in `analyses/` directory + README with run instructions. All queries use raw source table references (not dbt refs) so they can be pasted directly into Snowflake.
</objective>

<execution_context>
@/Users/riley/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riley/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-device-id-audit/02-RESEARCH.md

# Source table definitions needed for correct database.schema.table references
@models/staging/adjust/_adjust__sources.yml
@models/staging/amplitude/_amplitude__sources.yml

# Existing models to understand current device ID handling
@models/staging/adjust/v_stg_adjust__installs.sql
@models/staging/adjust/v_stg_adjust__touchpoints.sql
@models/staging/amplitude/v_stg_amplitude__merge_ids.sql
@models/intermediate/int_adjust_amplitude__device_mapping.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write device ID format audit and Amplitude investigation SQL queries</name>
  <files>analyses/audit_device_id_formats.sql, analyses/amplitude_device_id_investigation.sql</files>
  <action>
Create two SQL analysis files that can be run directly in Snowflake (not as dbt models -- use fully qualified table names, not `source()` or `ref()`).

**File 1: `analyses/audit_device_id_formats.sql`**

Profile device ID columns in Adjust source tables. Must include:

1. **Adjust iOS install device IDs** from `ADJUST.S3_DATA.IOS_ACTIVITY_INSTALL`:
   - COUNT and COUNT DISTINCT for GPS_ADID, ADID, IDFV, IDFA columns
   - Population percentage for each column (COUNT / total rows)
   - LENGTH distribution for each populated column
   - UUID format validation using REGEXP_LIKE for pattern `^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$`
   - UPPER vs lowercase check: COUNT where column = UPPER(column)
   - 5 sample values per column (non-null) using ARRAY_AGG with LIMIT or ROW_NUMBER
   - Filter to `ACTIVITY_KIND = 'install'` and last 60 days
   - GROUP BY PLATFORM (though iOS table should only have iOS)

2. **Adjust Android install device IDs** from `ADJUST.S3_DATA.ANDROID_ACTIVITY_INSTALL`:
   - Same profiling as iOS above
   - Pay special attention to GPS_ADID vs ADID vs IDFA relationship (research says IDFA = GPS_ADID on Android touchpoints)
   - Filter to `ACTIVITY_KIND = 'install'` and last 60 days

3. **Cross-platform summary** combining both in a UNION ALL with a header comment explaining what each column means.

Add clear SQL comments at the top explaining:
- Purpose: Profile device ID columns to understand population rates, formats, and casing
- How to run: Paste into dbt Cloud IDE SQL runner or Snowflake worksheet
- Expected output: One row per platform per source table with population stats and sample values

**File 2: `analyses/amplitude_device_id_investigation.sql`**

Investigate Amplitude DEVICE_ID format. This is the KEY investigation -- we need to understand what Amplitude actually stores as DEVICE_ID for Android vs iOS. Must include:

1. **Amplitude device ID format by platform** from `AMPLITUDEANALYTICS_AMPLITUDE_DB_364926_SHARE.SCHEMA_726530.EVENTS_726530`:
   - GROUP BY PLATFORM
   - COUNT and COUNT DISTINCT for DEVICE_ID
   - LENGTH distribution (MIN, MAX, AVG, MODE via APPROX_TOP_K or GROUP BY)
   - UUID format check: does DEVICE_ID match UUID pattern?
   - Trailing 'R' suffix check for Android: COUNT where RIGHT(DEVICE_ID, 1) = 'R'
   - After stripping 'R': does remaining string match UUID pattern?
   - 10 sample DEVICE_ID values per platform
   - Filter to `SERVER_UPLOAD_TIME >= DATEADD(day, -30, CURRENT_DATE)` and DEVICE_ID IS NOT NULL and PLATFORM IN ('iOS', 'Android')

2. **Amplitude ADID field investigation** (check if Amplitude captures advertising ID separately):
   - Query `INFORMATION_SCHEMA.COLUMNS` to list all columns in EVENTS_726530 table that contain 'ID' or 'DEVICE' or 'ADID' in the column name
   - If ADID column exists, profile it the same way as DEVICE_ID above

3. **MERGE_IDS table investigation** from `AMPLITUDEANALYTICS_AMPLITUDE_DB_364926_SHARE.SCHEMA_726530.MERGE_IDS_726530`:
   - List all columns (SELECT * LIMIT 0 or use INFORMATION_SCHEMA)
   - Profile the merge ID columns: what types of IDs are being merged?
   - Sample 20 rows to understand the table structure
   - COUNT total rows, COUNT DISTINCT merged_amplitude_id (or equivalent columns)

Add comments explaining the open questions this query answers:
- Q1: Is Amplitude Android DEVICE_ID a random ID or GPS_ADID?
- Q2: Does Amplitude have a separate ADID/advertising_id field?
- Q3: Does MERGE_IDS contain device-to-advertising-ID mappings?
  </action>
  <verify>
Both SQL files exist in `analyses/` directory. Each file:
- Contains valid Snowflake SQL syntax (no dbt Jinja)
- Uses fully qualified table names (ADJUST.S3_DATA.*, AMPLITUDEANALYTICS_AMPLITUDE_DB_364926_SHARE.SCHEMA_726530.*)
- Has header comments explaining purpose and how to run
- Includes GROUP BY PLATFORM in all aggregate queries
- Has date filters to scope to recent data (30-60 days)
  </verify>
  <done>
Two SQL analysis files exist that will reveal: (1) Adjust device ID column population, format, and casing by platform, and (2) Amplitude DEVICE_ID format, the 'R' suffix pattern, ADID field existence, and MERGE_IDS table structure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write baseline match rate SQL and analyses README</name>
  <files>analyses/baseline_match_rates.sql, analyses/README.md</files>
  <action>
**File 1: `analyses/baseline_match_rates.sql`**

Calculate current match rates between Adjust and Amplitude device IDs BEFORE any normalization changes. This establishes the "before" state for Phase 3 comparison. Use fully qualified Snowflake table names (not dbt refs).

Must include these match rate calculations:

1. **Android GPS_ADID match rate**:
   - Get distinct Adjust Android DEVICE_ID values (GPS_ADID, uppercased) from `ADJUST.S3_DATA.ANDROID_ACTIVITY_INSTALL` where ACTIVITY_KIND = 'install' and last 60 days
   - Get distinct Amplitude Android DEVICE_ID values from `AMPLITUDEANALYTICS_AMPLITUDE_DB_364926_SHARE.SCHEMA_726530.EVENTS_726530` where PLATFORM = 'Android' and last 60 days
   - Try direct match: UPPER(amplitude.DEVICE_ID) = adjust.GPS_ADID
   - Try match after stripping 'R' suffix: UPPER(LEFT(amplitude.DEVICE_ID, LENGTH(amplitude.DEVICE_ID) - 1)) = adjust.GPS_ADID WHERE RIGHT(amplitude.DEVICE_ID, 1) = 'R'
   - Report: total Adjust devices, total Amplitude devices, direct matches, R-stripped matches, match percentages

2. **iOS IDFV match rate**:
   - Get distinct Adjust iOS DEVICE_ID values (IDFV) from `ADJUST.S3_DATA.IOS_ACTIVITY_INSTALL` where ACTIVITY_KIND = 'install' and last 60 days
   - Get distinct Amplitude iOS DEVICE_ID values from EVENTS_726530 where PLATFORM = 'iOS' and last 60 days
   - Try match: UPPER(amplitude.DEVICE_ID) = UPPER(adjust.IDFV)
   - Report: total Adjust devices, total Amplitude devices, IDFV matches, match percentage

3. **iOS IDFA match rate**:
   - Get distinct Adjust iOS IDFA values (non-null only) from IOS_ACTIVITY_INSTALL
   - Match against Amplitude iOS DEVICE_ID
   - Report: total Adjust IDFA-populated devices, IDFA matches, match percentage

4. **Current int_adjust_amplitude__device_mapping match rate** (if the model is populated):
   - Query the existing device mapping model output table to get current state
   - Use the target schema: check both `DBT_WGTDATA` and `PROD` schemas for `INT_ADJUST_AMPLITUDE__DEVICE_MAPPING`
   - COUNT by PLATFORM, COUNT DISTINCT ADJUST_DEVICE_ID, COUNT DISTINCT AMPLITUDE_USER_ID

5. **Summary output**: A final SELECT that presents all rates in a single readable table with columns: PLATFORM, MATCH_TYPE, ADJUST_DEVICES, AMPLITUDE_DEVICES, MATCHED_DEVICES, MATCH_RATE_PCT

Add header comment explaining:
- Purpose: Establish baseline match rates BEFORE Phase 3 normalization changes
- IMPORTANT: These numbers are the "before" snapshot. Run again after Phase 3 for comparison.
- Date and filter parameters used

**File 2: `analyses/README.md`**

Create a README for the analyses directory explaining:
- What these files are (Phase 2 audit queries for device ID investigation)
- How to run them (paste into dbt Cloud IDE SQL runner or Snowflake worksheet)
- Order to run them (1. audit_device_id_formats.sql, 2. amplitude_device_id_investigation.sql, 3. baseline_match_rates.sql)
- Where to capture results (copy output to `.planning/phases/02-device-id-audit/findings/` directory)
- Note that these use raw table names (not dbt refs) so they work outside dbt context
  </action>
  <verify>
Both files exist. The match rate SQL:
- Contains 4+ distinct match rate calculations (Android GPS_ADID direct, Android R-stripped, iOS IDFV, iOS IDFA)
- Uses fully qualified Snowflake table names
- Has date filters (60 days)
- Produces a summary table with PLATFORM, MATCH_TYPE, and MATCH_RATE_PCT columns

The README:
- Lists all 3 SQL files with descriptions
- Contains run instructions mentioning dbt Cloud IDE
- Specifies run order
  </verify>
  <done>
Baseline match rate SQL exists covering all 4 match strategies (Android direct, Android R-stripped, iOS IDFV, iOS IDFA) plus current model state. README provides clear run instructions for the audit queries.
  </done>
</task>

</tasks>

<verification>
- All 4 files exist in `analyses/` directory: `audit_device_id_formats.sql`, `amplitude_device_id_investigation.sql`, `baseline_match_rates.sql`, `README.md`
- All SQL files use fully qualified Snowflake table names (no dbt Jinja)
- All SQL files have explanatory header comments
- All aggregate queries include GROUP BY PLATFORM
- Date filters are consistent (30-60 day lookback)
- README describes all files and provides run instructions
</verification>

<success_criteria>
- 3 SQL analysis files ready to paste into Snowflake/dbt Cloud IDE
- 1 README with run instructions
- SQL covers all DMAP-01 requirements: Adjust device IDs (GPS_ADID, IDFV, IDFA, ADID) and Amplitude DEVICE_ID by platform
- SQL covers DMAP-02 requirements: baseline match rates for Android GPS_ADID, iOS IDFA, iOS IDFV
- Queries answer the open research questions: Amplitude Android device ID format, ADID field existence, MERGE_IDS structure
</success_criteria>

<output>
After completion, create `.planning/phases/02-device-id-audit/02-01-SUMMARY.md`
</output>
