---
phase: 03-mta-limitations-mmm-foundation
plan: 03
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - models/marts/mmm/mmm__daily_channel_summary.sql
  - models/marts/mmm/mmm__weekly_channel_summary.sql
  - models/marts/mmm/_mmm__models.yml
autonomous: true

must_haves:
  truths:
    - "MMM daily summary mart joins spend + installs + revenue at DATE+PLATFORM+CHANNEL grain with date spine ensuring no gaps"
    - "Weekly summary rolls up daily data for MMM tools that prefer weekly granularity"
    - "Date spine cross-joined with channels produces complete time series even for zero-activity days"
    - "All MMM mart models compile successfully with dbt compile"
  artifacts:
    - path: "models/marts/mmm/mmm__daily_channel_summary.sql"
      provides: "Complete daily MMM input table with all metrics joined"
      contains: "date_spine"
    - path: "models/marts/mmm/mmm__weekly_channel_summary.sql"
      provides: "Weekly rollup of daily summary for long-term MMM"
      contains: "DATE_TRUNC"
    - path: "models/marts/mmm/_mmm__models.yml"
      provides: "Schema definitions for MMM mart models"
      contains: "mmm__daily_channel_summary"
  key_links:
    - from: "mmm__daily_channel_summary.sql"
      to: "int_mmm__daily_channel_spend"
      via: "ref() LEFT JOIN"
      pattern: "ref\\('int_mmm__daily_channel_spend'\\)"
    - from: "mmm__daily_channel_summary.sql"
      to: "int_mmm__daily_channel_installs"
      via: "ref() LEFT JOIN"
      pattern: "ref\\('int_mmm__daily_channel_installs'\\)"
    - from: "mmm__daily_channel_summary.sql"
      to: "int_mmm__daily_channel_revenue"
      via: "ref() LEFT JOIN"
      pattern: "ref\\('int_mmm__daily_channel_revenue'\\)"
    - from: "mmm__weekly_channel_summary.sql"
      to: "mmm__daily_channel_summary"
      via: "ref() with DATE_TRUNC('week')"
      pattern: "ref\\('mmm__daily_channel_summary'\\)"
---

<objective>
Build MMM mart models: a daily channel summary with date spine (no gaps) and a weekly rollup, plus compile verification.

Purpose: The daily summary mart is the primary MMM input table -- it joins spend, installs, and revenue at the DATE+PLATFORM+CHANNEL grain with a date spine ensuring complete time series (critical for MMM regression models). The weekly rollup provides an alternative grain for MMM tools that prefer weekly data. After creating these models, verify the entire MMM pipeline compiles successfully.

Output: 2 SQL mart models + 1 schema YAML in models/marts/mmm/, plus compile verification.
</objective>

<execution_context>
@/Users/riley/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riley/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-device-id-normalization-fix/03-RESEARCH.md
@models/intermediate/int_mmm__daily_channel_spend.sql (created in Plan 02)
@models/intermediate/int_mmm__daily_channel_installs.sql (created in Plan 02)
@models/intermediate/int_mmm__daily_channel_revenue.sql (created in Plan 02)
@packages.yml (dbt_utils already installed)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create daily channel summary mart with date spine</name>
  <files>models/marts/mmm/mmm__daily_channel_summary.sql</files>
  <action>
Create the directory `models/marts/mmm/` if it does not exist.

Create `models/marts/mmm/mmm__daily_channel_summary.sql` -- the primary MMM input table.

This model must:
1. Generate a date spine covering the full data range (use `dbt_utils.date_spine`)
2. Get distinct channels from all three intermediate models
3. Cross join date spine with channels to create the complete grid
4. LEFT JOIN spend, installs, and revenue data
5. COALESCE all metrics to 0 for gap-free time series
6. Calculate derived KPIs (CPI, ROAS)

```sql
{{ config(
    materialized='table',
    tags=['mmm', 'mart', 'summary']
) }}

-- mmm__daily_channel_summary.sql
-- Primary MMM input table: spend + installs + revenue at daily+channel+platform grain
-- Date spine ensures complete time series with no gaps (critical for MMM regression)
-- Grain: one row per DATE + PLATFORM + CHANNEL

-- Step 1: Get the date range from actual data
WITH date_bounds AS (
    SELECT
        LEAST(
            MIN(s.DATE),
            MIN(i.DATE),
            MIN(r.DATE)
        ) AS min_date,
        CURRENT_DATE() AS max_date
    FROM {{ ref('int_mmm__daily_channel_spend') }} s
    CROSS JOIN {{ ref('int_mmm__daily_channel_installs') }} i
    CROSS JOIN {{ ref('int_mmm__daily_channel_revenue') }} r
),

-- Step 2: Generate date spine
date_spine AS (
    {{ dbt_utils.date_spine(
        datepart="day",
        start_date="(SELECT min_date FROM date_bounds)",
        end_date="(SELECT max_date FROM date_bounds)"
    ) }}
),

dates AS (
    SELECT CAST(date_day AS DATE) AS DATE
    FROM date_spine
),

-- Step 3: Get distinct channel+platform combinations from all sources
channels AS (
    SELECT DISTINCT PLATFORM, CHANNEL FROM {{ ref('int_mmm__daily_channel_spend') }}
    UNION
    SELECT DISTINCT PLATFORM, CHANNEL FROM {{ ref('int_mmm__daily_channel_installs') }}
    UNION
    SELECT DISTINCT PLATFORM, CHANNEL FROM {{ ref('int_mmm__daily_channel_revenue') }}
),

-- Step 4: Create complete grid (every date x every channel+platform)
date_channel_grid AS (
    SELECT
        d.DATE,
        c.PLATFORM,
        c.CHANNEL
    FROM dates d
    CROSS JOIN channels c
),

-- Step 5: Join actual data
spend AS (
    SELECT DATE, PLATFORM, CHANNEL, SPEND, IMPRESSIONS, CLICKS, PAID_INSTALLS
    FROM {{ ref('int_mmm__daily_channel_spend') }}
),

installs AS (
    SELECT DATE, PLATFORM, CHANNEL, INSTALLS
    FROM {{ ref('int_mmm__daily_channel_installs') }}
),

revenue AS (
    SELECT DATE, PLATFORM, CHANNEL, REVENUE, ALL_REVENUE, AD_REVENUE, API_INSTALLS
    FROM {{ ref('int_mmm__daily_channel_revenue') }}
)

-- Step 6: Final output with all metrics
SELECT
    g.DATE,
    g.PLATFORM,
    g.CHANNEL,

    -- Spend metrics
    COALESCE(s.SPEND, 0) AS SPEND,
    COALESCE(s.IMPRESSIONS, 0) AS IMPRESSIONS,
    COALESCE(s.CLICKS, 0) AS CLICKS,
    COALESCE(s.PAID_INSTALLS, 0) AS PAID_INSTALLS_SUPERMETRICS,

    -- Install metrics (from device-level S3 data)
    COALESCE(i.INSTALLS, 0) AS INSTALLS,

    -- Revenue metrics (from Adjust API)
    COALESCE(r.REVENUE, 0) AS REVENUE,
    COALESCE(r.ALL_REVENUE, 0) AS ALL_REVENUE,
    COALESCE(r.AD_REVENUE, 0) AS AD_REVENUE,
    COALESCE(r.API_INSTALLS, 0) AS INSTALLS_API,

    -- Derived KPIs
    CASE WHEN COALESCE(i.INSTALLS, 0) > 0
         THEN COALESCE(s.SPEND, 0) / i.INSTALLS
         ELSE NULL
    END AS CPI,

    CASE WHEN COALESCE(s.SPEND, 0) > 0
         THEN COALESCE(r.REVENUE, 0) / s.SPEND
         ELSE NULL
    END AS ROAS,

    CASE WHEN COALESCE(s.SPEND, 0) > 0
         THEN COALESCE(r.ALL_REVENUE, 0) / s.SPEND
         ELSE NULL
    END AS ALL_ROAS,

    -- Data quality flags
    CASE WHEN s.SPEND IS NOT NULL THEN 1 ELSE 0 END AS HAS_SPEND_DATA,
    CASE WHEN i.INSTALLS IS NOT NULL THEN 1 ELSE 0 END AS HAS_INSTALL_DATA,
    CASE WHEN r.REVENUE IS NOT NULL THEN 1 ELSE 0 END AS HAS_REVENUE_DATA

FROM date_channel_grid g
LEFT JOIN spend s
    ON g.DATE = s.DATE AND g.PLATFORM = s.PLATFORM AND g.CHANNEL = s.CHANNEL
LEFT JOIN installs i
    ON g.DATE = i.DATE AND g.PLATFORM = i.PLATFORM AND g.CHANNEL = i.CHANNEL
LEFT JOIN revenue r
    ON g.DATE = r.DATE AND g.PLATFORM = r.PLATFORM AND g.CHANNEL = r.CHANNEL

ORDER BY g.DATE DESC, g.PLATFORM, g.CHANNEL
```

IMPORTANT NOTES:
- Use `materialized='table'` (not incremental) since this is a full-refresh mart with date spine. The date spine must regenerate the full grid each run. The intermediate models are incremental; this mart is the join layer.
- The `dbt_utils.date_spine` macro is already available (packages.yml has dbt-labs/dbt_utils >=1.1.1). The date_spine macro generates a `date_day` column.
- If the date_spine subquery approach does not work in Snowflake (dbt_utils may not accept subqueries as start/end dates), use an alternative approach: hardcode `start_date="'2024-01-01'"` and `end_date="current_date()"` since 2024-01-01 is the known data start boundary from staging model filters.
  </action>
  <verify>
File exists at `models/marts/mmm/mmm__daily_channel_summary.sql`. The file contains: date_spine generation, cross join with channels, LEFT JOINs to all 3 intermediate models, COALESCE to 0 for gap-free series, CPI and ROAS calculations, data quality flags.
  </verify>
  <done>
Daily channel summary mart exists with date spine ensuring complete time series. All three metric types (spend, installs, revenue) are joined at DATE+PLATFORM+CHANNEL grain with zero-fill for gaps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create weekly rollup, schema YAML, and compile verification</name>
  <files>
models/marts/mmm/mmm__weekly_channel_summary.sql
models/marts/mmm/_mmm__models.yml
  </files>
  <action>
**File 1: `models/marts/mmm/mmm__weekly_channel_summary.sql`**

Create a weekly rollup of the daily summary mart. Simple aggregation using DATE_TRUNC('week', DATE).

```sql
{{ config(
    materialized='table',
    tags=['mmm', 'mart', 'summary', 'weekly']
) }}

-- mmm__weekly_channel_summary.sql
-- Weekly rollup of daily channel summary for MMM tools preferring weekly data
-- Some MMM implementations (especially with limited history) work better at weekly grain
-- Grain: one row per WEEK_START_DATE + PLATFORM + CHANNEL

SELECT
    DATE_TRUNC('week', DATE) AS WEEK_START_DATE,
    PLATFORM,
    CHANNEL,

    -- Spend metrics (sum over week)
    SUM(SPEND) AS SPEND,
    SUM(IMPRESSIONS) AS IMPRESSIONS,
    SUM(CLICKS) AS CLICKS,
    SUM(PAID_INSTALLS_SUPERMETRICS) AS PAID_INSTALLS_SUPERMETRICS,

    -- Install metrics (sum over week)
    SUM(INSTALLS) AS INSTALLS,

    -- Revenue metrics (sum over week)
    SUM(REVENUE) AS REVENUE,
    SUM(ALL_REVENUE) AS ALL_REVENUE,
    SUM(AD_REVENUE) AS AD_REVENUE,
    SUM(INSTALLS_API) AS INSTALLS_API,

    -- Weekly KPIs (recomputed, not averaged)
    CASE WHEN SUM(INSTALLS) > 0
         THEN SUM(SPEND) / SUM(INSTALLS)
         ELSE NULL
    END AS CPI,

    CASE WHEN SUM(SPEND) > 0
         THEN SUM(REVENUE) / SUM(SPEND)
         ELSE NULL
    END AS ROAS,

    CASE WHEN SUM(SPEND) > 0
         THEN SUM(ALL_REVENUE) / SUM(SPEND)
         ELSE NULL
    END AS ALL_ROAS,

    -- Data coverage for the week
    SUM(HAS_SPEND_DATA) AS DAYS_WITH_SPEND,
    SUM(HAS_INSTALL_DATA) AS DAYS_WITH_INSTALLS,
    SUM(HAS_REVENUE_DATA) AS DAYS_WITH_REVENUE,
    COUNT(*) AS DAYS_IN_WEEK

FROM {{ ref('mmm__daily_channel_summary') }}
GROUP BY 1, 2, 3
ORDER BY 1 DESC, 2, 3
```

**File 2: `models/marts/mmm/_mmm__models.yml`**

Create schema YAML for both MMM mart models:

```yaml
version: 2

models:
  - name: mmm__daily_channel_summary
    description: >
      Primary MMM input table combining daily spend, installs, and revenue
      at the DATE + PLATFORM + CHANNEL grain. Uses a date spine to ensure
      complete time series with no gaps (critical for MMM regression models).
      Metrics are zero-filled for days without activity.
    columns:
      - name: DATE
        description: Calendar date
        tests:
          - not_null
      - name: PLATFORM
        description: "iOS or Android"
        tests:
          - not_null
          - accepted_values:
              values: ['iOS', 'Android']
      - name: CHANNEL
        description: "Standardized ad partner name (Meta, Google, TikTok, etc.)"
        tests:
          - not_null
      - name: SPEND
        description: "Marketing spend (from Supermetrics), 0 if no spend"
      - name: INSTALLS
        description: "Device-level installs (from Adjust S3), 0 if no installs"
      - name: REVENUE
        description: "Adjust-reported revenue, 0 if no revenue"
      - name: CPI
        description: "Cost per install (SPEND / INSTALLS), NULL if no installs"
      - name: ROAS
        description: "Return on ad spend (REVENUE / SPEND), NULL if no spend"
      - name: HAS_SPEND_DATA
        description: "1 if spend data exists for this row, 0 if zero-filled"
      - name: HAS_INSTALL_DATA
        description: "1 if install data exists for this row, 0 if zero-filled"
      - name: HAS_REVENUE_DATA
        description: "1 if revenue data exists for this row, 0 if zero-filled"

  - name: mmm__weekly_channel_summary
    description: >
      Weekly rollup of daily channel summary for MMM tools that prefer
      weekly granularity. All metrics are summed, KPIs recomputed from
      weekly totals (not averaged). Includes data coverage indicators.
    columns:
      - name: WEEK_START_DATE
        description: "Monday of the week (DATE_TRUNC('week'))"
        tests:
          - not_null
      - name: PLATFORM
        description: "iOS or Android"
        tests:
          - not_null
          - accepted_values:
              values: ['iOS', 'Android']
      - name: CHANNEL
        description: "Standardized ad partner name"
        tests:
          - not_null
      - name: SPEND
        description: "Weekly total marketing spend"
      - name: INSTALLS
        description: "Weekly total installs"
      - name: REVENUE
        description: "Weekly total revenue"
      - name: CPI
        description: "Weekly cost per install"
      - name: ROAS
        description: "Weekly return on ad spend"
      - name: DAYS_WITH_SPEND
        description: "Number of days in the week with actual spend data"
      - name: DAYS_IN_WEEK
        description: "Total days in the week (7, or less for partial weeks)"
```

Add `dbt_utils.unique_combination_of_columns` tests for the primary keys:
- daily: `[DATE, PLATFORM, CHANNEL]`
- weekly: `[WEEK_START_DATE, PLATFORM, CHANNEL]`

**After creating the files, verify the full MMM pipeline compiles:**

Since dbt cannot be run locally (dbt Cloud only, per project constraints), verify by:
1. Reading each model file and confirming all `ref()` targets exist as files
2. Checking that column names referenced in downstream models match upstream outputs
3. Confirming dbt_utils.date_spine macro is available (packages.yml already has dbt-labs/dbt_utils)

Document the ref() dependency chain:
```
stg_supermetrics__adj_campaign --> int_mmm__daily_channel_spend ──┐
v_stg_adjust__installs ---------> int_mmm__daily_channel_installs ├─> mmm__daily_channel_summary -> mmm__weekly_channel_summary
stg_adjust__report_daily -------> int_mmm__daily_channel_revenue ─┘
network_mapping (seed) ---------> int_mmm__daily_channel_spend
                               -> int_mmm__daily_channel_revenue
```
  </action>
  <verify>
1. `models/marts/mmm/mmm__daily_channel_summary.sql` exists with date spine and all 3 LEFT JOINs
2. `models/marts/mmm/mmm__weekly_channel_summary.sql` exists with DATE_TRUNC('week') rollup
3. `models/marts/mmm/_mmm__models.yml` exists with schema definitions and tests for both models
4. All ref() targets resolve to existing model files
5. No circular dependencies in the DAG
  </verify>
  <done>
MMM mart layer is complete: daily summary with date spine for gap-free time series, weekly rollup for alternative grain, schema YAML with documentation and tests. Full pipeline dependency chain verified.
  </done>
</task>

</tasks>

<verification>
1. `models/marts/mmm/` directory exists with 3 files (2 SQL + 1 YAML)
2. Daily summary has date spine producing complete time series
3. Weekly summary rolls up daily data correctly
4. All ref() calls resolve to existing models
5. dbt_utils.unique_combination_of_columns tests defined for primary keys
6. Dependency chain: staging -> int_mmm__* -> mmm__daily -> mmm__weekly (no cycles)
</verification>

<success_criteria>
- MMM daily summary mart exists joining spend + installs + revenue with date spine
- Weekly rollup exists for alternative MMM granularity
- No gaps in time series (date spine + COALESCE to 0)
- Full pipeline compiles (all refs resolve, no circular dependencies)
- Schema YAML provides documentation and data quality tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-device-id-normalization-fix/03-03-SUMMARY.md`
</output>
