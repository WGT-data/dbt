---
phase: 01-test-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages.yml
  - models/staging/adjust/_adjust__models.yml
  - models/staging/amplitude/_amplitude__models.yml
  - models/staging/revenue/_revenue__models.yml
autonomous: true

must_haves:
  truths:
    - "Staging model primary keys have unique and not_null tests defined"
    - "Platform columns have accepted_values tests for iOS and Android with not_null"
    - "All staging tests use forward-looking 60-day where filter"
    - "dbt-utils package is declared for composite key testing"
  artifacts:
    - path: "packages.yml"
      provides: "dbt-utils package declaration for composite key testing"
      contains: "dbt-labs/dbt_utils"
    - path: "models/staging/adjust/_adjust__models.yml"
      provides: "Tests for v_stg_adjust__installs and v_stg_adjust__touchpoints"
      contains: "data_tests"
    - path: "models/staging/amplitude/_amplitude__models.yml"
      provides: "Tests for v_stg_amplitude__merge_ids"
      contains: "data_tests"
    - path: "models/staging/revenue/_revenue__models.yml"
      provides: "Tests for v_stg_revenue__events"
      contains: "data_tests"
  key_links:
    - from: "models/staging/adjust/_adjust__models.yml"
      to: "v_stg_adjust__installs"
      via: "model name reference"
      pattern: "name: v_stg_adjust__installs"
    - from: "models/staging/adjust/_adjust__models.yml"
      to: "v_stg_adjust__touchpoints"
      via: "model name reference"
      pattern: "name: v_stg_adjust__touchpoints"
    - from: "packages.yml"
      to: "dbt_utils"
      via: "package declaration"
      pattern: "dbt-labs/dbt_utils"
---

<objective>
Install dbt-utils and add data quality tests to all staging models covering primary key uniqueness, not_null constraints, platform accepted_values, and forward-looking filters.

Purpose: Establishes the baseline staging-layer test coverage (TEST-01, TEST-04, TEST-05) so regressions from upcoming device ID normalization changes are caught immediately. The staging layer is where raw data enters the pipeline -- testing here catches problems before they propagate downstream.

Output: packages.yml with dbt-utils dependency, and three schema YAML files with generic tests for all staging models.
</objective>

<execution_context>
@/Users/riley/.claude/get-shit-done/workflows/execute-plan.md
@/Users/riley/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-test-foundation/01-RESEARCH.md
@models/staging/adjust/v_stg_adjust__installs.sql
@models/staging/adjust/v_stg_adjust__touchpoints.sql
@models/staging/amplitude/v_stg_amplitude__merge_ids.sql
@models/staging/revenue/v_stg_revenue__events.sql
@dbt_project.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create packages.yml and staging Adjust model tests</name>
  <files>packages.yml, models/staging/adjust/_adjust__models.yml</files>
  <action>
1. Create `packages.yml` in project root with dbt-utils dependency:
```yaml
packages:
  - package: dbt-labs/dbt_utils
    version: ">=1.1.1,<2.0.0"
```

2. Create `models/staging/adjust/_adjust__models.yml` with tests for both staging Adjust models.

For `v_stg_adjust__installs` (grain: one row per device, PK: DEVICE_ID):
- DEVICE_ID: unique + not_null with `where: "INSTALL_TIMESTAMP >= DATEADD(day, -60, CURRENT_DATE)"`
- PLATFORM: not_null + accepted_values ['iOS', 'Android'] with same where filter

For `v_stg_adjust__touchpoints` (grain: one row per touchpoint event, composite unique_key defined in config as ['PLATFORM', 'TOUCHPOINT_TYPE', 'TOUCHPOINT_EPOCH', 'NETWORK_NAME', 'CAMPAIGN_ID', 'IP_ADDRESS']):
- Model-level `dbt_utils.unique_combination_of_columns` test on the composite key columns: PLATFORM, TOUCHPOINT_TYPE, TOUCHPOINT_EPOCH, NETWORK_NAME, CAMPAIGN_ID, IP_ADDRESS -- with `where: "TOUCHPOINT_TIMESTAMP >= DATEADD(day, -60, CURRENT_DATE)"`
- PLATFORM: not_null + accepted_values ['iOS', 'Android'] with where filter
- TOUCHPOINT_EPOCH: not_null with where filter

Use `data_tests:` key (not legacy `tests:`). Use `arguments:` wrapper for test parameters per dbt v1.10.5+ syntax from research.

IMPORTANT: The `where` filter for v_stg_adjust__touchpoints must use `TOUCHPOINT_TIMESTAMP` (the timestamp column in the model), NOT `INSTALL_TIMESTAMP`. Each model's where filter should reference that model's own date/timestamp column.

Do NOT add descriptions to models -- only add the test definitions. Keep the YAML focused on tests only.
  </action>
  <verify>
Verify YAML syntax is valid: `python3 -c "import yaml; yaml.safe_load(open('packages.yml'))"`
Verify model YAML syntax: `python3 -c "import yaml; yaml.safe_load(open('models/staging/adjust/_adjust__models.yml'))"`
Verify the YAML contains the expected test patterns: grep for `data_tests`, `unique`, `not_null`, `accepted_values`, `unique_combination_of_columns`, and `DATEADD(day, -60`.
  </verify>
  <done>
packages.yml exists with dbt-utils >= 1.1.1. _adjust__models.yml contains: unique + not_null on v_stg_adjust__installs.DEVICE_ID, unique_combination_of_columns on v_stg_adjust__touchpoints composite key, accepted_values + not_null on PLATFORM for both models, all with 60-day where filters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create staging Amplitude and Revenue model tests</name>
  <files>models/staging/amplitude/_amplitude__models.yml, models/staging/revenue/_revenue__models.yml</files>
  <action>
1. Create `models/staging/amplitude/_amplitude__models.yml` with tests for v_stg_amplitude__merge_ids.

For `v_stg_amplitude__merge_ids` (grain: one row per device+user+platform, composite unique_key: ['DEVICE_ID_UUID', 'USER_ID_INTEGER', 'PLATFORM'] from the model config):
- Model-level `dbt_utils.unique_combination_of_columns` test on: DEVICE_ID_UUID, USER_ID_INTEGER, PLATFORM -- with `where: "FIRST_SEEN_AT >= DATEADD(day, -60, CURRENT_DATE)"`
- DEVICE_ID_UUID: not_null with where filter
- USER_ID_INTEGER: not_null with where filter
- PLATFORM: not_null + accepted_values ['iOS', 'Android'] with where filter

2. Create `models/staging/revenue/_revenue__models.yml` with tests for v_stg_revenue__events.

For `v_stg_revenue__events` (grain: one row per user+event_time+event_type, composite unique_key: ['USER_ID', 'EVENT_TIME', 'EVENT_TYPE'] from model config):
- Model-level `dbt_utils.unique_combination_of_columns` test on: USER_ID, EVENT_TIME, EVENT_TYPE -- with `where: "EVENT_TIME >= DATEADD(day, -60, CURRENT_DATE)"`
- USER_ID: not_null with where filter
- EVENT_TIME: not_null with where filter
- PLATFORM: not_null + accepted_values ['iOS', 'Android'] with where filter

Use `data_tests:` key and `arguments:` wrapper per dbt v1.10.5+ syntax.

Do NOT add model descriptions. Keep YAML focused on tests only.
  </action>
  <verify>
Verify YAML syntax: `python3 -c "import yaml; yaml.safe_load(open('models/staging/amplitude/_amplitude__models.yml'))"`
Verify YAML syntax: `python3 -c "import yaml; yaml.safe_load(open('models/staging/revenue/_revenue__models.yml'))"`
Grep for expected patterns: `data_tests`, `unique_combination_of_columns`, `accepted_values`, `DATEADD(day, -60`.
  </verify>
  <done>
_amplitude__models.yml contains: unique_combination_of_columns on v_stg_amplitude__merge_ids composite key, not_null on DEVICE_ID_UUID and USER_ID_INTEGER, accepted_values on PLATFORM. _revenue__models.yml contains: unique_combination_of_columns on v_stg_revenue__events composite key, not_null on USER_ID and EVENT_TIME, accepted_values on PLATFORM. All with 60-day where filters.
  </done>
</task>

</tasks>

<verification>
1. All four files exist and parse as valid YAML
2. Every staging model with a primary/composite key has unique (or unique_combination_of_columns) + not_null tests
3. Every model with a PLATFORM column has accepted_values ['iOS', 'Android'] + not_null tests
4. Every test has a `where` config with 60-day DATEADD lookback referencing the correct timestamp column for that model
5. packages.yml declares dbt-utils >= 1.1.1
6. No test bloat: only testing keys and constrained columns (PLATFORM), not every column
</verification>

<success_criteria>
- packages.yml exists with dbt-utils package declaration
- 3 staging model YAML files created with tests covering TEST-01 (PKs), TEST-04 (accepted_values), TEST-05 (where filters)
- All tests use `data_tests:` key with `arguments:` wrapper syntax
- All tests have 60-day forward-looking where filters
- YAML files parse without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-foundation/01-01-SUMMARY.md`
</output>
